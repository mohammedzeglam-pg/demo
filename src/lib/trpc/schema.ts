import { z } from 'zod';
import { mapKeys, camel } from 'radash';
const LevelSchema = z.union([
	z.literal('Alerts'),
	z.literal('Warnings'),
	z.literal('Notice'),
	z.literal('Info'),
	z.literal('Errors')
]);

export type LevelSchema = z.infer<typeof LevelSchema>;
export const ClientLogSchema = z
	.object({
		accessed: z.string().optional(),
		arch: z.string().optional(),
		arguments: z.string().optional(),
		author_1: z.string().optional(),
		author_2: z.string().optional(),
		author: z.string().optional(),
		build_number: z.string().optional(),
		cmd: z.string().optional(),
		command: z.string().optional(),
		company_1: z.string().optional(),
		company_2: z.string().optional(),
		company_3: z.string().optional(),
		company_4: z.string().optional(),
		company: z.string().optional(),
		connection_count: z.number().optional(),
		context: z.string().optional(),
		created_1: z.string().optional(),
		created_2: z.string().optional(),
		created_3: z.string().optional(),
		created_4: z.string().optional(),
		created: z.string().optional(),
		desc_1: z.string().optional(),
		desc_2: z.string().optional(),
		desc_3: z.string().optional(),
		desc_4: z.string().optional(),
		desc: z.string().optional(),
		duration: z.string().optional(),
		end_time: z.string().optional(),
		entries: z.number().optional(),
		entry: z.string().optional(),
		event_id: z.number().optional(),
		event_level: z.number().optional(),
		event_time: z.string().optional(),
		exists_1: z.string().optional(),
		exists_2: z.string().optional(),
		exists_3: z.string().optional(),
		exists_4: z.string().optional(),
		exists: z.string().optional(),
		expires: z.string().optional(),
		ext: z.string().optional(),
		file_1: z.string().optional(),
		file_2: z.string().optional(),
		file_3: z.string().optional(),
		file_4: z.string().optional(),
		file: z.string().optional(),
		firstbytes_1: z.string().optional(),
		firstbytes_2: z.string().optional(),
		firstbytes_3: z.string().optional(),
		firstbytes_4: z.string().optional(),
		firstbytes: z.string().optional(),
		hostname: z.string(),
		image_name: z.string().optional(),
		image_path: z.string().optional(),
		imphash_1: z.string().optional(),
		imphash_2: z.string().optional(),
		imphash_3: z.string().optional(),
		imphash_4: z.string().optional(),
		imphash: z.string().optional(),
		installed_on: z.string().optional(),
		internal_name_1: z.string().optional(),
		internal_name_2: z.string().optional(),
		internal_name_3: z.string().optional(),
		internal_name_4: z.string().optional(),
		internal_name: z.string().optional(),
		ip: z.string().optional(),
		launch_string: z.string().optional(),
		legal_copyright_1: z.string().optional(),
		legal_copyright_2: z.string().optional(),
		legal_copyright_3: z.string().optional(),
		legal_copyright_4: z.string().optional(),
		legal_copyright: z.string().optional(),
		level: LevelSchema,
		license: z.string().optional(),
		listen_ports: z.string().optional(),
		location: z.string().optional(),
		log_accessed: z.string().optional(),
		log_created: z.string().optional(),
		log_modified: z.string().optional(),
		log_version: z.number(),
		matched_1: z
			.array(z.object({ context: z.string(), data: z.string(), offset: z.number() }))
			.optional(),
		matched_2: z
			.array(z.object({ context: z.string(), data: z.string(), offset: z.number() }))
			.optional(),
		matched: z
			.array(z.object({ context: z.string(), data: z.string(), offset: z.number() }))
			.optional(),
		matched_strings: z
			.array(z.object({ context: z.string(), data: z.string(), offset: z.number() }))
			.optional(),
		md5_1: z.string().optional(),
		md5_2: z.string().optional(),
		md5_3: z.string().optional(),
		md5_4: z.string().optional(),
		md5: z.string().optional(),
		message: z.string(),
		modified: z.string().optional(),
		module: z.string(),
		modules: z.string().optional(),
		name: z.string().optional(),
		original_name_1: z.string().optional(),
		original_name_2: z.string().optional(),
		original_name_3: z.string().optional(),
		original_name: z.string().optional(),
		owner_1: z.string().optional(),
		owner_2: z.string().optional(),
		owner_3: z.string().optional(),
		owner_4: z.string().optional(),
		owner: z.string().optional(),
		parent: z.string().optional(),
		path: z.string().optional(),
		perm: z.string().optional(),
		permissions: z.string().optional(),
		pid: z.number().optional(),
		port: z.number().optional(),
		ppid: z.number().optional(),
		proc: z.string().optional(),
		process_name: z.string().optional(),
		product_1: z.string().optional(),
		product_2: z.string().optional(),
		product_3: z.string().optional(),
		product_4: z.string().optional(),
		product: z.string().optional(),
		reason_1: z.string().optional(),
		reason_2: z.string().optional(),
		reason: z.string().optional(),
		reasons_count: z.number().optional(),
		ref_1: z.string().optional(),
		ref_2: z.string().optional(),
		ref: z.string().optional(),
		reference: z.string().optional(),
		rip: z.string().optional(),
		rport: z.number().optional(),
		rule: z.string().optional(),
		ruledate_1: z.string().optional(),
		ruledate_2: z.string().optional(),
		ruledate: z.string().optional(),
		rulename_1: z.string().optional(),
		rulename_2: z.string().optional(),
		rulename: z.string().optional(),
		scanid: z.string(),
		scanned_elements: z.number().optional(),
		scanner: z.string().optional(),
		score: z.number().optional(),
		session: z.string().optional(),
		sha1_1: z.string().optional(),
		sha1_2: z.string().optional(),
		sha1_3: z.string().optional(),
		sha1: z.string().optional(),
		sha256_1: z.string().optional(),
		sha256_2: z.string().optional(),
		sha256_3: z.string().optional(),
		sha256_4: z.string().optional(),
		sha256: z.string().optional(),
		sigclass_1: z.string().optional(),
		sigclass_2: z.string().optional(),
		sigclass: z.string().optional(),
		sigtype_1: z.string().optional(),
		sigtype_2: z.string().optional(),
		sigtype: z.string().optional(),
		size_1: z.number().optional(),
		size_2: z.number().optional(),
		size_3: z.number().optional(),
		size_4: z.number().optional(),
		size: z.number().optional(),
		start_time: z.string().optional(),
		starts: z.string().optional(),
		subscore_1: z.number().optional(),
		subscore_2: z.number().optional(),
		subscore: z.number().optional(),
		tags_1: z.string().optional(),
		tags_2: z.string().optional(),
		tags: z.string().optional(),
		time: z.string(),
		type_1: z.string().optional(),
		type_2: z.string().optional(),
		type_3: z.string().optional(),
		type_4: z.string().optional(),
		type: z.string().optional(),
		user: z.string().optional(),
		valid: z.string().optional(),
		version: z.string().optional()
	})
	.transform((data) => {
		const filterToArray: Array<keyof typeof data> = [
			'author',
			'company',
			'created',
			'desc',
			'exists',
			'file',
			'firstbytes',
			'imphash',
			'internal_name',
			'legal_copyright',
			'matched',
			'md5',
			'original_name',
			'owner',
			'product',
			'ruledate',
			'reason',
			'ref',
			'rulename',
			'sha1',
			'sha256',
			'sigclass',
			'sigtype',
			'size',
			'subscore',
			'tags',
			'type'
		];
		for (const filter of filterToArray) {
			const values = Object.keys(data)
				.filter((k): k is keyof typeof data => k.startsWith(filter))
				.map((v) => {
					const value = data[v];
					delete data[v];
					return value;
				});
			const isArray = values.every(Array.isArray);
			if (isArray) {
				data = {
					...data,
					[filter]: values.reduce((p, c) => [...c, ...p], [])
				};
			} else {
				data = { ...data, [filter]: values };
			}
		}
		return mapKeys(data, camel);
	})
	.pipe(
		z.object({
			accessed: z.string().optional(),
			arch: z.string().optional(),
			arguments: z.string().optional(),
			author: z.array(z.string()).optional(),
			buildNumber: z.string().optional(),
			cmd: z.string().optional(),
			command: z.string().optional(),
			company: z.array(z.string()).optional(),
			connectionCount: z.number().optional(),
			context: z.string().optional(),
			created: z.array(z.string()).optional(),
			desc: z.array(z.string()).optional(),
			duration: z.string().optional(),
			endTime: z.string().optional(),
			entries: z.number().optional(),
			entry: z.string().optional(),
			eventId: z.number().optional(),
			eventLevel: z.number().optional(),
			eventTime: z.string().optional(),
			exists: z.array(z.string()).optional(),
			expires: z.string().optional(),
			ext: z.string().optional(),
			file: z.array(z.string()).optional(),
			firstbytes: z.array(z.string()).optional(),
			hostname: z.string(),
			imageName: z.string().optional(),
			imagePath: z.string().optional(),
			imphash: z.array(z.string()).optional(),
			installedOn: z.string().optional(),
			internalName: z.array(z.string()).optional(),
			ip: z.string().optional(),
			launchString: z.string().optional(),
			legalCopyright: z.array(z.string()).optional(),
			level: LevelSchema,
			license: z.string().optional(),
			listenPorts: z.string().optional(),
			location: z.string().optional(),
			logAccessed: z.string().optional(),
			logCreated: z.string().optional(),
			logModified: z.string().optional(),
			logVersion: z.number(),
			matched: z
				.array(z.object({ context: z.string(), data: z.string(), offset: z.number() }))
				.optional(),
			matchedStrings: z
				.array(z.object({ context: z.string(), data: z.string(), offset: z.number() }))
				.optional(),
			md5: z.array(z.string()).optional(),
			message: z.string(),
			modified: z.string().optional(),
			module: z.string(),
			modules: z.string().optional(),
			name: z.string().optional(),
			originalName: z.array(z.string()).optional(),
			owner: z.array(z.string()).optional(),
			parent: z.string().optional(),
			path: z.string().optional(),
			perm: z.string().optional(),
			permissions: z.string().optional(),
			pid: z.number().optional(),
			port: z.number().optional(),
			ppid: z.number().optional(),
			proc: z.string().optional(),
			processName: z.string().optional(),
			product: z.array(z.string()).optional(),
			reason: z.array(z.string()).optional(),
			reasonsCount: z.number().optional(),
			ref: z.array(z.string()).optional(),
			reference: z.string().optional(),
			rip: z.string().optional(),
			rport: z.number().optional(),
			rule: z.string().optional(),
			ruledate: z.array(z.string()).optional(),
			rulename: z.array(z.string()).optional(),
			scanid: z.string(),
			scannedElements: z.number().optional(),
			scanner: z.string().optional(),
			score: z.number().optional(),
			session: z.string().optional(),
			sha1: z.array(z.string()).optional(),
			sha256: z.array(z.string()).optional(),
			sigclass: z.array(z.string()).optional(),
			sigtype: z.array(z.string()).optional(),
			size: z.array(z.number()).optional(),
			startTime: z.string().optional(),
			starts: z.string().optional(),
			subscore: z.array(z.number()).optional(),
			tags: z.array(z.string()).optional(),
			time: z.string(),
			type: z.array(z.string()).optional(),
			user: z.string().optional(),
			valid: z.string().optional(),
			version: z.string().optional()
		})
	);

export type ClientLogSchema = z.infer<typeof ClientLogSchema>;
